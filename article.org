# -*- mode: org; coding: utf-8 -*-
#+TITLE: Linux kernel CVE analysis

* Linux kernel CVE analysis

- Published 24 January 2020 [[https://tuxcare.com/blog/linux-kernel-cve-data-analysis-updated/][tuxcare.com]]
- Updated 11 July 2021 (for personal use)
- Jul 2023 - Streamlining and converting to Python (WIP)

-----

What is the /best/ Linux kernel?

- The [[https://www.kernel.org/][latest release]]?

- The latest [[https://www.linux.com/news/which-linux-kernel-version-stable/][stable release]]?

- The latest stable release with [[https://wikipedia.org/wiki/Long-term_support][long-term support]]?

- Or, according to [[http://kroah.com/log/blog/2018/08/24/what-stable-kernel-should-i-use/][Linux kernel developers]], the one provided by your distribution?

Shouldn't it be the safest? If so, how do we measure that?

One way is look at how many security issues different versions of the Linux kernel suffer from.

In this article, I'll look at the number of Linux kernel CVEs across versions, charting the results by version and year of discovery.

Here are the tools I'll use:

- [[https://docs.docker.com/get-docker/][Docker]] to run an instance of [[https://docs.couchdb.org/][Apache CouchDB]].

- =curl= to download NVD JSON files.

- [[https://github.com/glynnbird/couchimport][couchimport]] to import them.

- [[https://github.com/cloudant/mango][Mango]] to query the data.

- Shell scripting to semi-automate the queries.

- =jq= for extracting JSON values.

- Gnu =seq= for shell loop ranges.

- [[http://www.gnuplot.info/][Gnuplot]] to chart the results.

The commands run on Debian 10 and macOS with [[https://brew.sh/][Homebrew]] or equivalent package manager installed.

** Prerequisites

1. [[https://docs.docker.com/get-docker/][Docker]] or [[http://docs.couchdb.org/en/latest/install/index.html][CouchDB]]

2. [[https://nodejs.org/en/download/][Node.js]]

3. [[http://www.gnuplot.info/][Gnuplot]]

4. [[https://github.com/glynnbird/couchimport][couchimport]]

5. =curl=

6. =jq=

** CouchDB

1. (If using Docker) Start:

   #+BEGIN_SRC sh
     sudo docker run -d -p 5984:5984 -e COUCHDB_USER=admin -e COUCHDB_PASSWORD=password --name couchdb couchdb
   #+END_SRC

2. Create database:

   #+BEGIN_SRC sh
     curl -X PUT http://admin:password@localhost:5984/nvd
   #+END_SRC

** Import CVE Data

#+begin_quote
See [[file:load_cve_data.sh]]
#+end_quote

1. Download and unpack CVE JSON data files for the years 2009 to the current year, inclusive:

   #+begin_src sh
     VERS="1.1"
     R="https://nvd.nist.gov/feeds/json/cve/${VERS}/"
     for YEAR in $(seq 2009 $(date +%Y))
     do
         FILE=$(printf "nvdcve-${VERS}-%s.json.gz" $YEAR)
         URL="${R}${FILE}"
         echo "Downloading ${URL} to ${FILE}"
         curl ${URL} --output ${FILE} --progress-bar --retry 10
     done
     gunzip *.gz
   #+end_src


1. Import downloaded data.

   #+BEGIN_SRC sh
     export \
     COUCH_URL="http://admin:password@localhost:5984" \
     COUCH_DATABASE="nvd" \
     COUCH_FILETYPE="json" \
     COUCH_BUFFER_SIZE=100
     for f in $(ls -1 nvdcve*.json); do
         echo "Importing ${f}"
         cat ${f} | couchimport --jsonpath "CVE_Items.*"
     done
   #+end_src

2. Check the number of records imported.

   #+BEGIN_SRC sh
     curl -sX GET ${COUCH_URL}/nvd | jq '.doc_count'
   #+END_SRC

3. Compare with the number of records downloaded.

   #+BEGIN_SRC sh
     grep CVE_data_numberOfCVEs nvdcve*.json | \
     cut -d':' -f3 | tr -cd '[:digit:][:cntrl:]' | \
     awk '{s+=$1} END {print s}'
   #+END_SRC

** Run a Mango Query in Fauxton                                                                                                    :noexport:archive:

[[https://couchdb.apache.org/fauxton-visual-guide/#using-fauxton][Fauxton]] is a web-based user interface for CouchDB. I'll use it just once to get started. Later queries will be done on the command line.

1. Go to [[http://localhost:5984/_utils/#database/nvd/_find][=http://localhost:5984/_utils/#database/nvd/_find=]]

2. Delete what's in the */Mango Query/* pane, copy and paste this in.

   #+begin_src json
     {
         "selector": {
             "configurations.nodes": {
                 "$elemMatch": {
                     "operator": "OR",
                     "cpe_match": {
                         "$elemMatch": {
                             "cpe23Uri": {
                                 "$regex": "linux_kernel"
                             }
                         }
                     }
                 }
             },
             "publishedDate": {
                 "$gte": "2021-01-01",
                 "$lte": "2021-12-31"
             }
         },
         "fields": [
             "cve.CVE_data_meta.ID"
         ],
         "limit": 999999
     }
   #+end_src

   #+begin_quote
     Edit the =publishedDate= values (lines 16 and 17) to try different date ranges.
   #+end_quote

3. Set */Documents per page/* to its highest value.

4. Click */Run Query/*.

The list is the CVE IDs of Linux kernel vulnerabilities for all severities and kernel versions, assigned or published in the date range specified.

** Query: Linux kernel CVEs by year

1. Create directories to keep files separate.

   #+begin_src sh
     mkdir bin img out qry
   #+end_src

2. Copy and paste the following into a new file in =qry/1-linux-kernel-cves-by-year.json=:

   #+BEGIN_EXAMPLE
   {
     "selector": {
       "configurations.nodes": {
         "$elemMatch": {
           "operator": "OR",
           "cpe_match": {
             "$elemMatch": {
               "cpe23Uri": {
                 "$regex": "linux_kernel"
               }
             }
           }
         }
       },
       "publishedDate": {
         "$gte": "%s-01-01",
         "$lte": "%s-12-31"
       }
     },
     "fields": [
       "cve.CVE_data_meta.ID"
     ],
     "limit": 999999
   }
   #+END_EXAMPLE

3. Run the query for each year in the range. The results appear in the console and the tab-separated file =out/1-linux-kernel-cves-by-year.tsv=.

   #+BEGIN_SRC sh
     for YEAR in $(seq 2009 $(date +%Y)); do
         echo -en "$YEAR\t"
         printf "$(cat qry/1-linux-kernel-cves-by-year.json)" \
                $YEAR $YEAR \
             | curl -sX POST -d @- http://admin:password@localhost:5984/nvd/_find \
             --header "Content-Type:application/json" \
             | jq '.docs | length'
     done | tee out/1-linux-kernel-cves-by-year.tsv
   #+END_SRC

   #+begin_quote
     If you don't get any results, check the query file and your CouchDB credentials (I used =admin=/=password=).
   #+end_quote

4. Here's my output.

   #+BEGIN_EXAMPLE
   2009    101
   2010    116
   2011    81
   2012    114
   2013    190
   2014    137
   2015    79
   2016    218
   2017    453
   2018    184
   2019    287
   2020    125
   2021    103
   #+END_EXAMPLE

   This is the total number of Linux kernel vulnerabilities per year. Compare them with the following numbers quoted by [[https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html?vendor_id=33][CVEDetails]]:

   #+BEGIN_EXAMPLE
   2009    104
   2010    118
   2011    81
   2012    114
   2013    186
   2014    128
   2015    79
   2016    215
   2017    449
   2018    178
   2019    289
   2020    126
   2021    105
   #+END_EXAMPLE

5. Create a Gnuplot script. Copy and paste the following into a new file in =>bin/1-linux-kernel-cves-by-year.gnuplot=:

   #+BEGIN_EXAMPLE
   reset
   set terminal png size 800,600
   set output 'img/1-linux-kernel-cves-by-year.png'
   set style fill solid 0.5
   set boxwidth 0.8 relative
   set xtics 1
   set key top right
   set title 'Linux Kernel CVEs by Year'
   set xlabel "Year"
   set ylabel "Number of CVEs"
   set autoscale y
   plot [2008.5:*] [] 'out/1-linux-kernel-cves-by-year.tsv' w boxes t 'All severities', 'out/1-linux-kernel-cves-by-year.tsv' u 1:($2+15):2 w labels t ''
   #+END_EXAMPLE

6. Run the Gnuplot script:

   #+BEGIN_SRC sh
     gnuplot -c bin/1-linux-kernel-cves-by-year.gnuplot
   #+END_SRC

7. Open the image file =img/1-linux-kernel-cves-by-year.png=. It should look like this:

   #+CAPTION: Linux Kernel CVEs by Year
   [[./img/1-linux-kernel-cves-by-year.png]]

** Linux kernel CVEs by year and severity

1. Copy and paste the following into a new file in =qry/2-linux-kernel-cves-by-year-and-severity.json=:

   #+BEGIN_EXAMPLE
   {
     "selector": {
       "configurations.nodes": {
         "$elemMatch": {
           "operator": "OR",
           "cpe_match": {
             "$elemMatch": {
               "cpe23Uri": {
                 "$regex": "linux_kernel"
               }
             }
           }
         }
       },
       "impact.baseMetricV2.severity": "%s",
       "publishedDate": {
         "$gte": "%s-01-01",
         "$lte": "%s-12-31"
       }
     },
     "fields": [
       "cve.CVE_data_meta.ID"
     ],
     "limit": 999999
   }
   #+END_EXAMPLE

2. Run this to tabulate the results of running the query for each year in the range:

   #+BEGIN_SRC sh
     export \
     OUT="2-linux-kernel-cves-by-year-and-severity" \
     SEVS=(LOW MEDIUM HIGH)
     (IFS=$'\t'; echo -e "YEAR\t${SEVS[*]}" | tee out/${OUT}.tsv); \
     for YEAR in $(seq 2009 $(date +%Y)); do
         RES=()
         echo -en "$YEAR\t"
         for SEV in ${SEVS[*]}; do
             RES+=($(printf "$(cat qry/${OUT}.json)" \
             ${SEV} ${YEAR} ${YEAR} \
             | curl -sX POST -d @- http://admin:password@localhost:5984/nvd/_find \
               --header "Content-Type:application/json" \
             | jq '.docs | length'))
         done
         (IFS=$'\t'; echo "${RES[*]}")
     done | tee -a out/${OUT}.tsv
   #+END_SRC

3. Create a Gnuplot script and run it to create the chart of the tabulated results.

   #+begin_src sh
     cat<<\EOF>bin/${OUT}.gnuplot
     reset
     set terminal png size 800,600
     set output "img/`echo ${OUT}`.png"
     set style data histograms
     set style histogram rowstacked
     set style fill solid 0.5
     set boxwidth 0.8 relative
     set xtics 1
     set key top right title "Severity"
     set title "Linux kernel CVEs"
     set xlabel "Year"
     set ylabel "Number of CVEs"
     set autoscale y
     plot "out/`echo ${OUT}`.tsv" \
     u ($2):xtic(1) t col, \
     '' u ($3):xtic(1) t col, \
     '' u ($4):xtic(1) t col, \
     '' u ($0-1):($2+10):(sprintf("%d",$2)) with labels t '', \
     '' u ($0-1):($2+$3+10):(sprintf("%d",$3)) with labels t '', \
     '' u ($0-1):($2+$3+$4+10):(sprintf("%d",$4)) with labels t ''
     EOF
     gnuplot -c bin/${OUT}.gnuplot
   #+end_src

4. Open =img/2-linux-kernel-cves-by-year-and-severity.png=. Here's mine.

   #+attr_latex: :width 300px
   [[file:img/2-linux-kernel-cves-by-year-and-severity.png]]

** Linux kernel CVEs by year and version (2.6.x)

1. Create a query file.

   #+begin_src sh
     export QRY="3-linux-kernel-cves-by-year-and-version"
     cat<<\EOF>qry/${QRY}.json
     {
         "selector": {
             "configurations.nodes": {
                 "$elemMatch": {
                     "operator": "OR",
                     "cpe_match": {
                         "$elemMatch": {
                             "cpe23Uri": {
                                 "$regex": "linux_kernel:%s"
                             }
                         }
                     }
                 }
             },
             "publishedDate": {
                 "$gte": "%s-01-01",
                 "$lte": "%s-12-31"
             }
         },
         "fields": [
             "cve.CVE_data_meta.ID"
         ],
         "limit": 999999
     }
     EOF
   #+end_src

2. Run it.

   #+begin_src sh
     export \
     VERS_MAJOR=2.6 \
     VERS_MINOR_START=35 \
     VERS_MINOR_STOP=39 \
     YEAR_START=2009 \
     YEAR_STOP=$(date +%Y) \
     VERSIONS=() \
     COUCHDB_URL="http://admin:password@localhost:5984/nvd/_find" \
     QRY="3-linux-kernel-cves-by-year-and-version"
     export OUT="${QRY}_${VERS_MAJOR}.x"
     for VERS_MINOR in $(seq ${VERS_MINOR_START} ${VERS_MINOR_STOP}); do
         VERSIONS+=(${VERS_MAJOR}.${VERS_MINOR});
     done
     (IFS=$'\t'; echo -e "\t${VERSIONS[*]}" | tee out/${OUT}.tsv); \
     for Y in $(seq ${YEAR_START} ${YEAR_STOP}); do
         RES=()
         echo -en "${Y}\t"
         for V in ${VERSIONS[*]}; do
             RES+=($(printf "$(cat qry/${QRY}.json)" ${V} ${Y} ${Y} \
             | curl -sX POST -d @- ${COUCHDB_URL} \
             --header "Content-Type:application/json" \
             | jq '.docs | length'))
         done
         (IFS=$'\t'; echo "${RES[*]}")
     done | tee -a out/${OUT}.tsv
   #+end_src

3. Create the Gnuplot script and run it.

   #+begin_src sh
     cat<<\EOF>bin/${OUT}.gnuplot
     reset
     set terminal png size 800,600
     set output "img/`echo ${OUT}`.png"
     set xtics 1
     set key top right autotitle columnheader title "Kernel Version"
     set title "Linux kernel CVEs by version (`echo ${VERS_MAJOR}`.x)"
     set xlabel "Year"
     set ylabel "Number of CVEs"
     set autoscale y
     plot [] [] for [c=2:*] "out/`echo ${OUT}`.tsv" \
     using 1:c with lines lw 3
     EOF
     gnuplot -c bin/${OUT}.gnuplot
   #+end_src

4. Here's the image I get.

   #+attr_latex: :width 300px
   [[file:img/3-linux-kernel-cves-by-year-and-version_2.6.x.png]]

** Linux kernel CVEs by year and version (Template for 3.x, 4.x, 5.x)

The next code block generates charts for Linux kernel branches 3.x, 4.x and 5.x.

Set these environment variable values and run the code. (The code block is ready to run for 3.x.)

| Variable           | 3.x  | 4.x  | 5.x  |
|--------------------+------+------+------|
| =VERS_MAJOR=       | 3    | 4    | 5    |
| =VERS_MINOR_START= | 0    | 0    | 0    |
| =VERS_MINOR_STOP=  | 19   | 20   | 12   |
| =YEAR_START=       | 2011 | 2015 | 2019 |

#+begin_quote
  The version ranges and dates are taken from [[https://kernelnewbies.org/LinuxVersions][kernelnewbies.org]].
#+end_quote

#+begin_src sh
  export \
  VERS_MAJOR=3 \
  VERS_MINOR_START=0 \
  VERS_MINOR_STOP=19 \
  YEAR_START=2011 \
  YEAR_STOP=$(date +%Y) \
  VERSIONS=() \
  COUCHDB_URL="http://admin:password@localhost:5984/nvd/_find" \
  QRY="3-linux-kernel-cves-by-year-and-version"
  export OUT="${QRY}_${VERS_MAJOR}.x"
  for VERS_MINOR in $(seq ${VERS_MINOR_START} ${VERS_MINOR_STOP}); do
      VERSIONS+=(${VERS_MAJOR}.${VERS_MINOR})
  done
  (IFS=$'\t'; echo -e "\t${VERSIONS[*]}" | tee out/${OUT}.tsv); \
  for Y in $(seq ${YEAR_START} ${YEAR_STOP}); do
      RES=()
      echo -en "${Y}\t"
      for V in ${VERSIONS[*]}; do
          RES+=($(printf "$(cat qry/${QRY}.json)" ${V} ${Y} ${Y} \
          | curl -sX POST -d @- ${COUCHDB_URL} \
          --header "Content-Type:application/json" \
          | jq '.docs | length'))
      done
  (IFS=$'\t'; echo "${RES[*]}")
  done | tee -a out/${OUT}.tsv
  cat<<\EOF>bin/${OUT}.gnuplot
  reset
  set terminal png size 800,600
  set output "img/`echo ${OUT}`.png"
  set xtics 1
  set key top right autotitle columnheader title "Kernel Version"
  set title "Linux kernel CVEs by version (`echo ${VERS_MAJOR}`.x)"
  set xlabel "Year"
  set ylabel "Number of CVEs"
  set autoscale y
  plot [] [] for [c=2:*] "out/`echo ${OUT}`.tsv" \
  using 1:c with lines lw 3
  EOF
  gnuplot -c bin/${OUT}.gnuplot
#+end_src

Here are the charts.

#+attr_latex: :width 300px
[[file:img/3-linux-kernel-cves-by-year-and-version_3.x.png]]

#+attr_latex: :width 300px
[[file:img/3-linux-kernel-cves-by-year-and-version_4.x.png]]

#+attr_latex: :width 300px
[[file:img/3-linux-kernel-cves-by-year-and-version_5.x.png]]

** Conclusions

- Taken together, the complete set of graphs for all major Linux kernel branches seems to answer my original question: the safest Linux kernel (the one with least vulnerabilities) is the latest.

- An end-of-life kernel doesn't mean the end of reported vulnerabilities. Version [[http://lkml.iu.edu/hypermail/linux/kernel/1108.0/01203.html][2.6.39.4]] (August 2011) was the last release of the 2.6 branch but vulnerabilities affecting it continue to be reported.

- It's unfair to compare vulnerabilities in this way, as the numbering scheme doesn't represent major differences in the code base. 5.x is based on 4.x, 4.0 on 3.19, 3.0 on 2.6.39. Consequently, each major release benefits from bug squashing in earlier releases.

** Acknowledgements

Something along these lines has been done before, and I want to acknowledge their inspirations.

- [[https://avleonov.com/2017/10/03/downloading-and-analyzing-nvd-cve-feed/][Alexander Leonov]]: CVE data file structure, focussing on [[https://nvd.nist.gov/products/cpe][CPE]].
- [[https://www.cvedetails.com/][CVE Details]]: A CVE search engine to find CVEs by severity, product, vendor, etc.
- [[https://www.linuxkernelcves.com/][Linux Kernel CVEs]]: A CVE search engine, with CVE IDs for specific Linux kernels.
- [[https://www.tenable.com/sc-dashboards/cve-analysis][Tenable.sc]]: A commercial CVE analysis dashboard.


#+begin_quote
  This article is derived from one I wrote for the [[https://blog.kernelcare.com/linux-kernel-cve-data-analysis-part-1-importing-into-couchdb][KernelCare]] blog in late 2019. The key differences are:

  - Mango queries use [[https://csrc.nist.gov/schema/nvd/feed/1.1/nvd_cve_feed_json_1.1.schema][CVE JSON 1.1]] specification.
  - Analyses Linux kernel versions up to mid-2021.
  - Three parts merged into one.
  - CouchDB as a Docker container.
  - =jq= replaces =json_pp=.
  - =seq= replaces loop ranges.
  - Rephrased or removed commentary.
#+end_quote
